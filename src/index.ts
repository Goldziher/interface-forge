/* eslint-disable unicorn/no-new-array */

import { en, Faker, LocaleDefinition, Randomizer } from '@faker-js/faker';
import { isIterator, isRecord } from '@tool-belt/type-predicates';
import { CycleGenerator, SampleGenerator } from './generators';
import { merge, Ref } from './utils';

export { Ref } from './utils';

export type FactoryComposition<T> = {
    [K in keyof T]?: Factory<T[K]> | T[K];
};

export type FactoryFunction<T> = (
    factory: Factory<T>,
    iteration: number,
) => FactorySchema<T>;

export type FactorySchema<T> = {
    [K in keyof T]:
        | Generator<T[K], T[K], T[K]>
        | Ref<T[K], (...args: unknown[]) => T[K]>
        | T[K];
};

/**
 * Builds a single object based on the factory's schema.
 * This method generates an instance by applying the factory function and optionally merging
 * the provided `kwargs` with the generated values. It's useful for creating a single, customized
 * instance where specific properties can be overridden or added.
 *
 * @param kwargs Optional. An object containing properties to override or add to the generated instance.
 *               Each property in `kwargs` will replace or add to the properties generated by the factory function.
 * @returns An instance of type `T`, generated and optionally modified according to the `kwargs` parameter.
 */
export class Factory<T> extends Faker {
    private readonly factory: FactoryFunction<T>;
    private readonly maxDepth: number;

    constructor(
        factory: FactoryFunction<T>,
        options?: {
            /**
             * The locale data to use for this instance.
             * If an array is provided, the first locale that has a definition for a given property will be used.
             */
            locale?: LocaleDefinition | LocaleDefinition[];
            /**
             * Maximum recursion depth for nested factory references.
             * Default is 10. Set to 0 to disable nested generation.
             */
            maxDepth?: number;
            /**
             * The Randomizer to use.
             * Specify this only if you want to use it to achieve a specific goal,
             * such as sharing the same random generator with other instances/tools.
             */
            randomizer?: Randomizer;
        },
    ) {
        super({
            locale: options?.locale ?? en,
            randomizer: options?.randomizer,
        });

        this.factory = factory;
        this.maxDepth = options?.maxDepth ?? 10;
    }

    /**
     * Generates a batch of objects based on the factory's schema.
     * This method allows for the creation of multiple instances at once, optionally applying specific
     * properties to each instance through the `kwargs` parameter. It supports both individual property
     * overrides for each instance in the batch or a single set of overrides applied to all instances.
     *
     * @param size The number of instances to generate in the batch.
     * @param kwargs Optional. An object or an array of objects containing properties to override in the
     *               generated instances. If an array is provided, each object in the array corresponds
     *               to the overrides for the instance at the same index in the batch. If a single object
     *               is provided, its properties are applied to all instances in the batch.
     * @returns An array of instances generated by the factory, with each instance optionally modified
     *          according to the `kwargs` parameter.
     *
     * @example
     * const ProductFactory = new Factory<Product>((factory) => ({
     *     id: factory.string.uuid(),
     *     name: factory.commerce.productName(),
     *     price: factory.number.float({ min: 10, max: 100 }),
     * }));
     *
     * // Create 5 products
     * const products = ProductFactory.batch(5);
     *
     * // Create 3 products with the same category
     * const electronics = ProductFactory.batch(3, { category: 'Electronics' });
     *
     * // Create products with individual overrides
     * const customProducts = ProductFactory.batch(2, [
     *     { name: 'Special Product 1', price: 99.99 },
     *     { name: 'Special Product 2', price: 149.99 }
     * ]);
     */
    batch = (size: number, kwargs?: Partial<T> | Partial<T>[]): T[] => {
        if (!Number.isInteger(size) || size < 0) {
            throw new Error('Batch size must be a non-negative integer');
        }

        if (size === 0) {
            return [];
        }

        if (kwargs) {
            const generator = this.iterate<Partial<T>>(
                Array.isArray(kwargs) ? kwargs : ([kwargs] as Partial<T>[]),
            );

            return new Array(size)
                .fill(null)
                .map((_, i) => this.#generate(i, generator.next().value, 0));
        }

        return new Array(size)
            .fill(null)
            .map((_, i) => this.#generate(i, undefined, 0));
    };

    /**
     * Builds a single object based on the factory's schema.
     * This method generates an instance by applying the factory function and optionally merging
     * the provided `kwargs` with the generated values. It's useful for creating a single, customized
     * instance where specific properties can be overridden or added.
     *
     * @param kwargs Optional. An object containing properties to override or add to the generated instance.
     *               Each property in `kwargs` will replace or add to the properties generated by the factory function.
     * @returns An instance of type `T`, generated and optionally modified according to the `kwargs` parameter.
     *
     * @example
     * const UserFactory = new Factory<User>((factory) => ({
     *     id: factory.string.uuid(),
     *     name: factory.person.fullName(),
     *     email: factory.internet.email(),
     * }));
     *
     * // Build with defaults
     * const user = UserFactory.build();
     *
     * // Build with overrides
     * const adminUser = UserFactory.build({
     *     email: 'admin@example.com'
     * });
     */
    build = (kwargs?: Partial<T>): T => {
        return this.#generate(0, kwargs, 0);
    };

    /**
     * Composes the current factory with other factories or values to create a new factory.
     * This method allows for factory composition, where a factory can include properties
     * generated by other factories or static values.
     *
     * @template U The type of the composed factory
     * @param composition An object that defines how to compose the factory with other factories or values
     * @returns A new Factory instance that combines the base factory's properties with the composed ones
     *
     * @example
     * const UserFactory = new Factory<User>((factory) => ({
     *     name: factory.person.fullName(),
     *     email: factory.internet.email(),
     * }));
     *
     * const PostFactory = new Factory<Post>((factory) => ({
     *     title: factory.lorem.sentence(),
     *     content: factory.lorem.paragraph(),
     * }));
     *
     * const UserWithPostsFactory = UserFactory.compose({
     *     posts: PostFactory.batch(3),
     * });
     */
    compose<U extends T>(composition: FactoryComposition<U>): Factory<U> {
        return new Factory<U>(
            (_factory, iteration) => {
                const baseValues = this.factory(
                    this,
                    iteration,
                ) as FactorySchema<U>;
                const composedValues = Object.fromEntries(
                    Object.entries(composition).map(
                        ([key, value]) =>
                            [
                                key,
                                value instanceof Factory
                                    ? value.build()
                                    : value,
                            ] as [string, unknown],
                    ),
                );
                return { ...baseValues, ...composedValues } as FactorySchema<U>;
            },
            { maxDepth: this.maxDepth },
        );
    }

    /**
     * Extends the current factory to create a new factory with additional or overridden properties.
     * This method allows for factory inheritance, where a new factory can build upon an existing one
     * while adding or modifying specific properties.
     *
     * @template U The type of the extended factory, which must extend the base type T
     * @param factoryFn A function that receives the factory instance and iteration number,
     *                 and returns an object with additional or overridden properties
     * @returns A new Factory instance that combines the base factory's properties with the new ones
     *
     * @example
     * const BaseUserFactory = new Factory<BaseUser>((factory) => ({
     *     id: factory.datatype.uuid(),
     *     createdAt: factory.date.recent(),
     * }));
     *
     * const AdminUserFactory = BaseUserFactory.extend<AdminUser>((factory) => ({
     *     role: 'admin',
     *     permissions: ['read', 'write', 'delete'],
     * }));
     */
    extend<U extends T>(factoryFn: FactoryFunction<U>): Factory<U> {
        return new Factory<U>(
            (factory, iteration) => {
                const baseValues = this.factory(
                    this,
                    iteration,
                ) as FactorySchema<U>;
                const extendedValues = factoryFn(factory, iteration);
                return { ...baseValues, ...extendedValues };
            },
            { maxDepth: this.maxDepth },
        );
    }

    /**
     * Cycles through the values of an iterable indefinitely.
     * This method creates a generator that iterates over each element of the provided iterable.
     * Once it reaches the end of the iterable, it starts over from the beginning, allowing for infinite iteration.
     *
     * @template T The type of elements in the iterable.
     * @param iterable An iterable object containing the elements to cycle through.
     * @returns A Generator that yields elements from the iterable indefinitely.
     *
     * @example
     * const UserFactory = new Factory<User>((factory) => ({
     *     id: factory.string.uuid(),
     *     name: factory.person.fullName(),
     *     role: factory.iterate(['admin', 'user', 'moderator']),
     *     status: factory.iterate(['active', 'inactive']),
     * }));
     *
     * // Creates users with roles cycling through: admin, user, moderator, admin, user...
     * const users = UserFactory.batch(5);
     */
    iterate<T>(iterable: Iterable<T>): Generator<T, T, T> {
        const generator = new CycleGenerator(iterable);
        return generator.generate();
    }

    /**
     * Samples values randomly from an iterable.
     * This method creates a generator that yields random values from the provided iterable.
     * Each iteration randomly selects an element from the iterable, ensuring that the same value
     * is not yielded consecutively unless the iterable contains a single element. This method
     * allows for an infinite sequence of random values from the iterable, suitable for scenarios
     * where random sampling with replacement is needed, but with a constraint to prevent immediate
     * repetition of the same value.
     *
     * @template T The type of elements in the iterable.
     * @param iterable An iterable object containing the elements to sample from.
     * @returns A Generator that yields random elements from the iterable indefinitely, ensuring no immediate repetitions.
     *
     * @example
     * const ProductFactory = new Factory<Product>((factory) => ({
     *     id: factory.string.uuid(),
     *     name: factory.commerce.productName(),
     *     category: factory.sample(['Electronics', 'Books', 'Clothing', 'Food']),
     *     color: factory.sample(['Red', 'Blue', 'Green', 'Yellow', 'Black', 'White']),
     * }));
     *
     * // Creates products with random categories and colors (no consecutive duplicates)
     * const products = ProductFactory.batch(10);
     */
    sample<T>(iterable: Iterable<T>): Generator<T, T, T> {
        const generator = new SampleGenerator(iterable);
        return generator.generate();
    }

    /**
     * Creates a reference to a function that can be used within the factory.
     * This method allows for the encapsulation of a function and its arguments, enabling deferred execution.
     *
     * @template R The return type of the function.
     * @template C The type of the function, constrained to functions that return `R`.
     * @param handler The function to be encapsulated.
     * @param args The arguments to be passed to the function upon invocation.
     * @returns A `Ref` instance encapsulating the function and its arguments, allowing for deferred execution.
     *
     * @example
     * const PostFactory = new Factory<Post>((factory) => ({
     *     id: factory.string.uuid(),
     *     title: factory.lorem.sentence(),
     *     content: factory.lorem.paragraphs(3),
     * }));
     *
     * const UserFactory = new Factory<User>((factory) => ({
     *     id: factory.string.uuid(),
     *     name: factory.person.fullName(),
     *     posts: factory.use(PostFactory.batch, 3),
     *     favoritePost: factory.use(PostFactory.build),
     * }));
     *
     * // Creates a user with 3 posts and a favorite post
     * const user = UserFactory.build();
     */
    use<C extends (...args: unknown[]) => unknown>(
        handler: C,
        ...args: Parameters<C>
    ): Ref<ReturnType<C>, C> {
        return new Ref<ReturnType<C>, C>({ args, handler });
    }

    #generate(iteration: number, kwargs?: Partial<T>, depth = 0): T {
        if (depth >= this.maxDepth) {
            // Return null/undefined for nested factories when max depth is reached
            return null as T;
        }

        // Create a depth-limited version of this factory for nested calls
        const depthLimitedFactory = new Proxy(this, {
            get(target, prop) {
                if (prop === 'build') {
                    return (buildKwargs?: Partial<T>) =>
                        target.#generate(0, buildKwargs, depth + 1);
                }
                if (prop === 'batch') {
                    return (
                        size: number,
                        batchKwargs?: Partial<T> | Partial<T>[],
                    ) => {
                        if (depth + 1 >= target.maxDepth) {
                            return null;
                        }
                        if (!Number.isInteger(size) || size < 0) {
                            throw new Error(
                                'Batch size must be a non-negative integer',
                            );
                        }
                        if (size === 0) {
                            return [];
                        }
                        if (batchKwargs) {
                            const generator = target.iterate<Partial<T>>(
                                Array.isArray(batchKwargs)
                                    ? batchKwargs
                                    : ([batchKwargs] as Partial<T>[]),
                            );
                            return new Array(size)
                                .fill(null)
                                .map((_, i) =>
                                    target.#generate(
                                        i,
                                        generator.next().value,
                                        depth + 1,
                                    ),
                                );
                        }
                        return new Array(size)
                            .fill(null)
                            .map((_, i) =>
                                target.#generate(i, undefined, depth + 1),
                            );
                    };
                }
                return Reflect.get(target, prop);
            },
        });

        const defaults = this.factory(
            depthLimitedFactory as Factory<T>,
            iteration,
        );

        if (kwargs) {
            return merge(
                this.#parseValue(defaults),
                this.#parseValue(kwargs),
            ) as T;
        }

        return this.#parseValue(defaults) as T;
    }

    #parseValue(value: unknown): unknown {
        if (value instanceof Ref) {
            return value.callHandler();
        }

        if (isIterator(value)) {
            return (value as Iterator<unknown>).next().value;
        }

        if (isRecord(value)) {
            const result: Record<string, unknown> = {};
            for (const [key, val] of Object.entries(
                value as Record<string, unknown>,
            )) {
                result[key] = this.#parseValue(val);
            }
            return result;
        }

        return value;
    }
}
