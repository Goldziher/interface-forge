/* eslint-disable unicorn/no-new-array */

import { en, Faker, LocaleDefinition, Randomizer } from '@faker-js/faker';
import { isIterator, isRecord } from '@tool-belt/type-predicates';

type FactoryFunction<T> = (
    factory: Factory<T>,
    iteration: number,
) => FactorySchema<T>;

type FactorySchema<T> = {
    [K in keyof T]:
        | Generator<T[K], T[K], T[K]>
        | Ref<T[K], (...args: unknown[]) => T[K]>
        | T[K];
};


/*
 * A reference to a function that returns a value of type `T`.
 * */
class Ref<T, C extends (...args: unknown[]) => T> {
    private readonly args: Parameters<C>;
    private readonly handler: C;

    constructor({ args, handler }: { args: Parameters<C>; handler: C }) {
        this.handler = handler;
        this.args = args;
    }
    
    callHandler(): T {
        return this.handler(...this.args);
    }
}

type BeforeBuildHook<T> = (params: Partial<T>) => Partial<T> | Promise<Partial<T>>; 
type AfterBuildHook<T> = (obj: T) => T | Promise<T>;

/**
 * Builds a single object based on the factory's schema.
 * This method generates an instance by applying the factory function and optionally merging
 * the provided `kwargs` with the generated values. It's useful for creating a single, customized
 * instance where specific properties can be overridden or added.
 * @param kwargs Optional. An object containing properties to override or add to the generated instance.
 *               Each property in `kwargs` will replace or add to the properties generated by the factory function.
 * @returns An instance of type `T`, generated and optionally modified according to the `kwargs` parameter.
 */
export class Factory<T> extends Faker {
    private readonly factory: FactoryFunction<T>;
    private beforeBuildHooks: BeforeBuildHook<T>[] = [];
    private afterBuildHooks: AfterBuildHook<T>[] = [];

    constructor(
        factory: FactoryFunction<T>,
        options?: {
            /**
             * The locale data to use for this instance.
             * If an array is provided, the first locale that has a definition for a given property will be used.
             */
            locale?: LocaleDefinition | LocaleDefinition[];
            /**
             * The Randomizer to use.
             * Specify this only if you want to use it to achieve a specific goal,
             * such as sharing the same random generator with other instances/tools.
             */
            randomizer?: Randomizer;
        },
    ) {
        super({
            locale: options?.locale ?? en,
            randomizer: options?.randomizer,
        });

        this.factory = factory;
    }

    /**
     * Generates a batch of objects based on the factory's schema.
     * This method allows for the creation of multiple instances at once, optionally applying specific
     * properties to each instance through the `kwargs` parameter. It supports both individual property
     * overrides for each instance in the batch or a single set of overrides applied to all instances.
     * @param size The number of instances to generate in the batch.
     * @param kwargs Optional. An object or an array of objects containing properties to override in the
     *               generated instances. If an array is provided, each object in the array corresponds
     *               to the overrides for the instance at the same index in the batch. If a single object
     *               is provided, its properties are applied to all instances in the batch.
     * @returns An array of instances generated by the factory, with each instance optionally modified
     *          according to the `kwargs` parameter.
     */
    batch = (size: number, kwargs?: Partial<T> | Partial<T>[]): T[] => {
        if (kwargs) {
            const generator = this.iterate<Partial<T>>(
                Array.isArray(kwargs) ? kwargs : ([kwargs] as Partial<T>[]),
            );

            return new Array(size)
                .fill(null)
                .map((_, i) => this.generate(i, generator.next().value));
        }

        return new Array(size).fill(null).map((_, i) => this.generate(i));
    };

    /**
     * Builds a single object based on the factory's schema.
     * This method generates an instance by applying the factory function and optionally merging
     * the provided `kwargs` with the generated values. It's useful for creating a single, customized
     * instance where specific properties can be overridden or added.
     * @param kwargs Optional. An object containing properties to override or add to the generated instance.
     *               Each property in `kwargs` will replace or add to the properties generated by the factory function.
     * @returns An instance of type `T`, generated and optionally modified according to the `kwargs` parameter.
     */
    build = (kwargs?: Partial<T>): T => {
        return this.generate(0, kwargs);
    };

    /**
     * Adds a hook that will be executed before building the instance.
     * @param hook. Function that takes partial parameters and returns partial parameters.
     * @returns The current Factory instance.
     */
    beforeBuild(hook: BeforeBuildHook<T>): this {
        if (typeof hook !== 'function') {
            throw new TypeError('Hook must be a function');
        }
        this.beforeBuildHooks.push(hook);
        return this;
    }

    /**
     * Adds a hook that will be executed after building the instance.
     * @param hook. Function that takes the result and returns the result.
     * @returns The current Factory instance.
     */
    afterBuild(hook: AfterBuildHook<T>): this {
        if (typeof hook !== 'function') {
            throw new TypeError('Hook must be a function');
        }
        this.afterBuildHooks.push(hook);
        return this;
    }

    /**
     * Constructs an instance of T by applying hooks before and after construction.
     * @param kwargs - Partial parameters for instance construction.
     * @returns A promise that resolves to a T instance.
     */
    async buildWithHooks(kwargs?: Partial<T>): Promise<T> {
        let params = kwargs ?? {};
        let result: T;
        try {
            for (const hook of this.beforeBuildHooks) {
                params = await hook(params);
            }
            result = this.build(params);
            
            for (const hook of this.afterBuildHooks) {
                result = await hook(result);
            }
        } catch (error) {
            console.error('Error in the hooks:', error);
            throw error;
        }
        return result;
    }

    /**
     * Cycles through the values of an iterable indefinitely.
     * This method creates a generator that iterates over each element of the provided iterable.
     * Once it reaches the end of the iterable, it starts over from the beginning, allowing for infinite iteration.
     * @template T The type of elements in the iterable.
     * @param iterable An iterable object containing the elements to cycle through.
     * @returns A Generator that yields elements from the iterable indefinitely.
     */
    iterate<T>(iterable: Iterable<T>): Generator<T, T, T> {
        const values = iterableToArray(iterable);
        return (function* () {
            let counter = 0;
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            while (true) {
                const value = values[counter];
                if (counter === values.length - 1) {
                    counter = 0;
                } else {
                    counter++;
                }
                yield value;
            }
        })();
    }

    /**
     * Samples values randomly from an iterable.
     * This method creates a generator that yields random values from the provided iterable.
     * Each iteration randomly selects an element from the iterable, ensuring that the same value
     * is not yielded consecutively unless the iterable contains a single element. This method
     * allows for an infinite sequence of random values from the iterable, suitable for scenarios
     * where random sampling with replacement is needed, but with a constraint to prevent immediate
     * repetition of the same value.
     * @template T The type of elements in the iterable.
     * @param iterable An iterable object containing the elements to sample from.
     * @returns A Generator that yields random elements from the iterable indefinitely, ensuring no immediate repetitions.
     */
    sample<T>(iterable: Iterable<T>): Generator<T, T, T> {
        const values = iterableToArray(iterable);
        return (function* () {
            let lastValue = null;
            let newValue = null;
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            while (true) {
                if (values.length <= 1) {
                    yield values[0];
                }
                lastValue = newValue;
                while (newValue === lastValue) {
                    newValue =
                        values[Math.floor(Math.random() * values.length)];
                }
                yield newValue;
            }
        })();
    }

    /**
     * Creates a reference to a function that can be used within the factory.
     * This method allows for the encapsulation of a function and its arguments, enabling deferred execution.
     * @template R The return type of the function.
     * @template C The type of the function, constrained to functions that return `R`.
     * @param handler The function to be encapsulated.
     * @param args The arguments to be passed to the function upon invocation.
     * @returns A `Ref` instance encapsulating the function and its arguments, allowing for deferred execution.
     */
    use<C extends (...args: never) => unknown>(
        handler: C,
        ...args: Parameters<C>
    ): ReturnType<C> {
        // @ts-expect-error, any and never clash
        return new Ref<ReturnType<C>, C>({ args, handler }) as ReturnType<C>;
    }

    protected generate(iteration: number, kwargs?: Partial<T>): T {
        const defaults = this.factory(this, iteration);

        if (kwargs) {
            return merge(
                this.parseValue(defaults),
                this.parseValue(kwargs),
            ) as T;
        }

        return this.parseValue(defaults) as T;
    }

    protected parseValue(value: unknown): unknown {
        if (value instanceof Ref) {
            return value.callHandler();
        }
        if (isIterator(value)) {
            return value.next().value;
        }
        if (isRecord(value)) {
            return Object.fromEntries(
                Object.entries(value).map(([k, v]) => [k, this.parseValue(v)]),
            );
        }
        return value;
    }
}

/**
 *
 * @param iterable The iterable to be converted to an array.
 * @returns An array containing the values of the iterable.
 */
function iterableToArray<T>(iterable: Iterable<T>): T[] {
    const values: T[] = [];
    for (const value of iterable) {
        values.push(value);
    }
    return values;
}

/**
 *
 * @param target The target object to merge into
 * @param {...any} sources The source objects to merge
 * @returns T
 */
function merge<T>(target: T, ...sources: unknown[]): T {
    const output: Partial<T> = { ...target };
    for (const source of sources.filter(Boolean) as Partial<T>[]) {
        for (const [key, value] of Object.entries(source)) {
            const existingValue: unknown = Reflect.get(output, key);
            if (isRecord(value) && isRecord(existingValue)) {
                Reflect.set(output, key, merge(existingValue, value));
            } else {
                Reflect.set(output, key, value);
            }
        }
    }
    return output as T;
}
