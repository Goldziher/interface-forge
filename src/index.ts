/* eslint-disable unicorn/no-new-array */

import { en, Faker, LocaleDefinition, Randomizer } from '@faker-js/faker';
import { isIterator, isRecord } from '@tool-belt/type-predicates';
import { iterableToArray, merge, Ref } from './utils';

export { Ref } from './utils';

export type FactoryComposition<T> = {
    [K in keyof T]?: Factory<T[K]> | T[K];
};

export type FactoryFunction<T> = (
    factory: Factory<T>,
    iteration: number,
) => FactorySchema<T>;

export type FactorySchema<T> = {
    [K in keyof T]:
        | Generator<T[K], T[K], T[K]>
        | Ref<T[K], (...args: unknown[]) => T[K]>
        | T[K];
};

/**
 * Builds a single object based on the factory's schema.
 * This method generates an instance by applying the factory function and optionally merging
 * the provided `kwargs` with the generated values. It's useful for creating a single, customized
 * instance where specific properties can be overridden or added.
 * @param kwargs Optional. An object containing properties to override or add to the generated instance.
 *               Each property in `kwargs` will replace or add to the properties generated by the factory function.
 * @returns An instance of type `T`, generated and optionally modified according to the `kwargs` parameter.
 */
export class Factory<T> extends Faker {
    private readonly factory: FactoryFunction<T>;

    constructor(
        factory: FactoryFunction<T>,
        options?: {
            /**
             * The locale data to use for this instance.
             * If an array is provided, the first locale that has a definition for a given property will be used.
             */
            locale?: LocaleDefinition | LocaleDefinition[];
            /**
             * The Randomizer to use.
             * Specify this only if you want to use it to achieve a specific goal,
             * such as sharing the same random generator with other instances/tools.
             */
            randomizer?: Randomizer;
        },
    ) {
        super({
            locale: options?.locale ?? en,
            randomizer: options?.randomizer,
        });

        this.factory = factory;
    }

    /**
     * Generates a batch of objects based on the factory's schema.
     * This method allows for the creation of multiple instances at once, optionally applying specific
     * properties to each instance through the `kwargs` parameter. It supports both individual property
     * overrides for each instance in the batch or a single set of overrides applied to all instances.
     * @param size The number of instances to generate in the batch.
     * @param kwargs Optional. An object or an array of objects containing properties to override in the
     *               generated instances. If an array is provided, each object in the array corresponds
     *               to the overrides for the instance at the same index in the batch. If a single object
     *               is provided, its properties are applied to all instances in the batch.
     * @returns An array of instances generated by the factory, with each instance optionally modified
     *          according to the `kwargs` parameter.
     */
    batch = (size: number, kwargs?: Partial<T> | Partial<T>[]): T[] => {
        if (kwargs) {
            const generator = this.iterate<Partial<T>>(
                Array.isArray(kwargs) ? kwargs : ([kwargs] as Partial<T>[]),
            );

            return new Array(size)
                .fill(null)
                .map((_, i) => this.generate(i, generator.next().value));
        }

        return new Array(size).fill(null).map((_, i) => this.generate(i));
    };

    /**
     * Builds a single object based on the factory's schema.
     * This method generates an instance by applying the factory function and optionally merging
     * the provided `kwargs` with the generated values. It's useful for creating a single, customized
     * instance where specific properties can be overridden or added.
     * @param kwargs Optional. An object containing properties to override or add to the generated instance.
     *               Each property in `kwargs` will replace or add to the properties generated by the factory function.
     * @returns An instance of type `T`, generated and optionally modified according to the `kwargs` parameter.
     */
    build = (kwargs?: Partial<T>): T => {
        return this.generate(0, kwargs);
    };

    /**
     * Composes the current factory with other factories or values to create a new factory.
     * This method allows for factory composition, where a factory can include properties
     * generated by other factories or static values.
     *
     * @template U The type of the composed factory
     * @param composition An object that defines how to compose the factory with other factories or values
     * @returns A new Factory instance that combines the base factory's properties with the composed ones
     *
     * @example
     * const UserFactory = new Factory<User>((factory) => ({
     *     name: factory.person.fullName(),
     *     email: factory.internet.email(),
     * }));
     *
     * const PostFactory = new Factory<Post>((factory) => ({
     *     title: factory.lorem.sentence(),
     *     content: factory.lorem.paragraph(),
     * }));
     *
     * const UserWithPostsFactory = UserFactory.compose({
     *     posts: PostFactory.batch(3),
     * });
     */
    compose<U extends T>(composition: FactoryComposition<U>): Factory<U> {
        return new Factory<U>((_factory, iteration) => {
            const baseValues = this.factory(
                this,
                iteration,
            ) as FactorySchema<U>;
            const composedValues = Object.fromEntries(
                Object.entries(composition).map(
                    ([key, value]) =>
                        [
                            key,
                            value instanceof Factory ? value.build() : value,
                        ] as [string, unknown],
                ),
            );
            return { ...baseValues, ...composedValues } as FactorySchema<U>;
        });
    }

    /**
     * Extends the current factory to create a new factory with additional or overridden properties.
     * This method allows for factory inheritance, where a new factory can build upon an existing one
     * while adding or modifying specific properties.
     *
     * @template U The type of the extended factory, which must extend the base type T
     * @param factoryFn A function that receives the factory instance and iteration number,
     *                 and returns an object with additional or overridden properties
     * @returns A new Factory instance that combines the base factory's properties with the new ones
     *
     * @example
     * const BaseUserFactory = new Factory<BaseUser>((factory) => ({
     *     id: factory.datatype.uuid(),
     *     createdAt: factory.date.recent(),
     * }));
     *
     * const AdminUserFactory = BaseUserFactory.extend<AdminUser>((factory) => ({
     *     role: 'admin',
     *     permissions: ['read', 'write', 'delete'],
     * }));
     */
    extend<U extends T>(factoryFn: FactoryFunction<U>): Factory<U> {
        return new Factory<U>((factory, iteration) => {
            const baseValues = this.factory(
                this,
                iteration,
            ) as FactorySchema<U>;
            const extendedValues = factoryFn(factory, iteration);
            return { ...baseValues, ...extendedValues };
        });
    }

    /**
     * Cycles through the values of an iterable indefinitely.
     * This method creates a generator that iterates over each element of the provided iterable.
     * Once it reaches the end of the iterable, it starts over from the beginning, allowing for infinite iteration.
     * @template T The type of elements in the iterable.
     * @param iterable An iterable object containing the elements to cycle through.
     * @returns A Generator that yields elements from the iterable indefinitely.
     */
    iterate<T>(iterable: Iterable<T>): Generator<T, T, T> {
        const values = iterableToArray(iterable);
        return (function* () {
            let counter = 0;
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            while (true) {
                const value = values[counter];
                if (counter === values.length - 1) {
                    counter = 0;
                } else {
                    counter++;
                }
                yield value;
            }
        })();
    }

    /**
     * Samples values randomly from an iterable.
     * This method creates a generator that yields random values from the provided iterable.
     * Each iteration randomly selects an element from the iterable, ensuring that the same value
     * is not yielded consecutively unless the iterable contains a single element. This method
     * allows for an infinite sequence of random values from the iterable, suitable for scenarios
     * where random sampling with replacement is needed, but with a constraint to prevent immediate
     * repetition of the same value.
     * @template T The type of elements in the iterable.
     * @param iterable An iterable object containing the elements to sample from.
     * @returns A Generator that yields random elements from the iterable indefinitely, ensuring no immediate repetitions.
     */
    sample<T>(iterable: Iterable<T>): Generator<T, T, T> {
        const values = iterableToArray(iterable);
        return (function* () {
            let lastValue = null;
            let newValue = null;
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            while (true) {
                if (values.length <= 1) {
                    yield values[0];
                }
                lastValue = newValue;
                while (newValue === lastValue) {
                    newValue =
                        values[Math.floor(Math.random() * values.length)];
                }
                yield newValue;
            }
        })();
    }

    /**
     * Creates a reference to a function that can be used within the factory.
     * This method allows for the encapsulation of a function and its arguments, enabling deferred execution.
     * @template R The return type of the function.
     * @template C The type of the function, constrained to functions that return `R`.
     * @param handler The function to be encapsulated.
     * @param args The arguments to be passed to the function upon invocation.
     * @returns A `Ref` instance encapsulating the function and its arguments, allowing for deferred execution.
     */
    use<C extends (...args: never) => unknown>(
        handler: C,
        ...args: Parameters<C>
    ): ReturnType<C> {
        // @ts-expect-error, any and never clash
        return new Ref<ReturnType<C>, C>({ args, handler }) as ReturnType<C>;
    }

    protected generate(iteration: number, kwargs?: Partial<T>): T {
        const defaults = this.factory(this, iteration);

        if (kwargs) {
            return merge(
                this.parseValue(defaults),
                this.parseValue(kwargs),
            ) as T;
        }

        return this.parseValue(defaults) as T;
    }

    protected parseValue(value: unknown): unknown {
        if (value instanceof Ref) {
            return value.callHandler();
        }
        if (isIterator(value)) {
            const iterator = value as Iterator<unknown>;
            return iterator.next().value;
        }
        if (isRecord(value)) {
            const record = value as Record<string, unknown>;
            return Object.fromEntries(
                Object.entries(record).map(([k, v]) => [k, this.parseValue(v)]),
            );
        }
        return value;
    }
}
